;; This File contains various functions generating ansi escape sequences for colorful output

(def ansi-wrap (λ (c s) "Wraps string s in the ansi color c"
	((ansi-fg c) s (ansi-fg 15))))

(def ansi-black (λ (...s) "Wraps its arguments as a string in the a red ansi color code"
	(ansi-wrap 0 (apply cat ...s))))
(def ansi-dark-red (λ (...s) "Wraps its arguments as a string in the a red ansi color code"
	(ansi-wrap 1 (apply cat ...s))))
(def ansi-darkgreen (λ (...s) "Wraps its arguments as a string in the a green ansi color code"
	(ansi-wrap 2 (apply cat ...s))))
(def ansi-brown (λ (...s) "Wraps its arguments as a string in the a yellow ansi color code"
	(ansi-wrap 3 (apply cat ...s))))
(def ansi-dark-blue (λ (...s) "Wraps its arguments as a string in the a blue ansi color code"
	(ansi-wrap 4 (apply cat ...s))))
(def ansi-purple (λ (...s) "Wraps its arguments as a string in the a pink ansi color code"
	(ansi-wrap 5 (apply cat ...s))))
(def ansi-teal (λ (...s) "Wraps its arguments as a string in the a cyan ansi color code"
	(ansi-wrap 6 (apply cat ...s))))
(def ansi-dgrey (λ (...s) "Wraps its arguments as a string in the a white ansi color code"
	(ansi-wrap 7 (apply cat ...s))))

(def ansi-grey (λ (...s) "Wraps its arguments as a string in the a red ansi color code"
	(ansi-wrap 8 (apply cat ...s))))
(def ansi-red (λ (...s) "Wraps its arguments as a string in the a red ansi color code"
	(ansi-wrap 9 (apply cat ...s))))
(def ansi-green (λ (...s) "Wraps its arguments as a string in the a green ansi color code"
	(ansi-wrap 10 (apply cat ...s))))
(def ansi-yellow (λ (...s) "Wraps its arguments as a string in the a yellow ansi color code"
	(ansi-wrap 11 (apply cat ...s))))
(def ansi-blue (λ (...s) "Wraps its arguments as a string in the a blue ansi color code"
	(ansi-wrap 12 (apply cat ...s))))
(def ansi-pink (λ (...s) "Wraps its arguments as a string in the a pink ansi color code"
	(ansi-wrap 13 (apply cat ...s))))
(def ansi-cyan (λ (...s) "Wraps its arguments as a string in the a cyan ansi color code"
	(ansi-wrap 14 (apply cat ...s))))
(def ansi-white (λ (...s) "Wraps its arguments as a string in the a white ansi color code"
	(ansi-wrap 15 (apply cat ...s))))

(def ansi-rainbow (λ (...s) "Wraps its arguments in the colors of the rainbow"
	(let ((count 0)) (join (map (λ (a) (set! count (logand (++ count) #x7)) (ansi-wrap (if (zero? count) 7 (+ count 8)) a)) (split (apply cat ...s) "")) ""))))
;; Contains everything related to the yield/coroutine system

(def yield-queue (cons "Start of Yield Queue"))
(def yield (λ (pred expr) "Executes expr once pred is true, returns immediately otherwise"
	(set-cdr! (last-pair yield-queue) (cons (cons pred expr))) #t))

(def yield-try (λ (l) "Tries to evaluate part an entry of the yield queue"
	(cond ((eval (car l)) (eval (cdr l)) #t)
	      (#t #f))))

(def yield-run-iter (λ (l) "Iter for yield-run"
	(cond ((nil? l) #t)
	      ((nil? (cdr l)) #t)
	      ((yield-try (cadr l)) (set-cdr! l (cddr l)) (yield-run-iter l))
	      (#t (yield-run-iter (cdr l))))))

(def yield-run (λ () "Executes pending coroutines if their predicate now evaluates to #t"
	(yield-run-iter yield-queue)))

(def timeout (λ (millis) "Returns a function that evaluates to true once millis milliseconds have passed"
	(let ((goal (+ (msecs) millis))) (λ () (> (msecs) goal)))))

(def event-bind (λ (event-name handler) "Binds handler lambda to event-name"
	(set! (str->sym event-name) (cons handler (resolve (str->sym event-name))))))
(def event-clear (λ (event-name) "Clears all event handlers for event-name"
	(set! (str->sym event-name) '())))
(def event-fire-iter (λ (l v) "Iter for event-fire"
	(cond ((nil? l) #t)
	      (#t (apply (car l) v) (event-fire-iter (cdr l) v)))))
(def event-fire (λ (event-name ...val) "Applies ...val to all event handlers associated with event-name"
	(event-fire-iter (resolve (str->sym event-name)) ...val)))
;; Wolkenwelten - Copyright (C) 2020-2021 - Benjamin Vincent Schulenburg
;;
;; This program is free software: you can redistribute it and/or modify
;; it under the terms of the GNU Affero General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or
;; (at your option) any later version.
;;
;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU Affero General Public License for more details.
;;
;; You should have received a copy of the GNU Affero General Public License
;; along with this program.  If not, see <http://www.gnu.org/licenses/>.

;; Contains various little pieces that were implemented in nujel instead of
;; C because of various reasons

(def caar (λ (p) "(car (car p))"
	(car (car p))))

(def cadr (λ (p) "(car (cdr p))"
	(car (cdr p))))

(def cdar (λ (p) "(cdr (car p))"
	(cdr (car p))))

(def cddr (λ (p) "(cdr (cdr p))"
	(cdr (cdr p))))

(def caddr (λ (p) "(car (cdr (cdr p)))"
	(car (cdr (cdr p)))))

(def ++ (λ (i) "(+ I 1)"
	(+ i 1)))

(def -- (λ (i) "(- I 1)"
	(- i 1)))

(def length (λ (a) "Returns the length of a"
	(cond ((string? a) (str-len a))
              ((pair? a) (list-length a))
              (#t 0))))

(def describe (λ (a) "Returns the DocString to its argument, if available"
	(cond ((not (string? a)) "Please quote the symbol in question, like (describe \"help\")")
	      (#t (let ((ds (car (cl-text (resolve (str->sym a)))))
	      (args (arg-list (resolve (str->sym a))))
	      (fn (cat a)))
		("(" fn args ") - " (if (string? ds) ds "No DocString found")))))))

(def display (λ (a) "Displays its argument"
	(print a)))

(def newline (λ () "Prints a single line feed character"
	(display "\n")))

(def list (λ (...l) "Returns its arguments as a list"
	...l))

(def when   (δ (c @...expr) "Evaluates l and returns the last result if c is #t"
	(cond (c (eval (cons 'begin @...expr))) (#t #f))))
(def unless (δ (c @...expr) "Evaluates l and returns the last result if c is #f"
	(cond (c #f) (#t (eval (cons 'begin @...expr))))))

(def arr-fill! (λ (a v i) "Fills array a with value v"
	(cond ((>= i (arr-length a)) a)
	      (#t (a (int i) v) (arr-fill! a v (++ i))))))

(def min-iter (λ (a l) "Iter for (min)"
	(cond ((nil? l) a)
	      ((< a (car l)) (min-iter a (cdr l)))
	      (#t (min-iter (car l) (cdr l))))))
(def min (λ (...l) "Returns the minimum value of its arguments"
	(cond ((nil? ...l) 0)
	      ((nil? (cdr ...l)) (car ...l))
	      (#t (min-iter (car ...l) (cdr ...l))))))

(def max-iter (λ (a l) "Iter for (max)"
	(cond ((nil? l) a)
	      ((> a (car l)) (max-iter a (cdr l)))
	      (#t (max-iter (car l) (cdr l))))))
(def max (λ (...l) "Returns the maximum value of its arguments"
	(cond ((nil? ...l) 0)
	      ((nil? (cdr ...l)) (car ...l))
	      (#t (max-iter (car ...l) (cdr ...l))))))

(def lognand (λ (...l) "Returns the Nand of its arguments"
	(lognot (apply logand ...l))))
;; Some predicates that were simpler to do in nujel

(def number? (λ (a) "Returns #t if a is a number"
	(or (int? a) (float? a) (vec? a))))

(def empty? (λ (a) "Returns #t if a is empty"
	(nil? a)))

(def last? (λ (a) "Returns #t if a is the last pair in a list"
	(nil? (cdr a))))

(def pos? (λ (a) "Returns #t if a is positive"
	(>= a 0)))

(def neg? (λ (a) "Returns #t if a is negative"
	(< a 0)))

(def ineq? (λ (a b) "Returns #t a does not equal b"
	(not (eq? a b))))

(def there-exists? (λ (l pred) "Applies predicate to each element and return #t if it holds true for any element, otherwise #f"
	(cond ((nil? l) #f)
	      ((pred (car l)) #t)
	      (#t (there-exists? (cdr l) pred)))))

(def for-all? (λ (l pred) "Applies predicate to each element returns #t if it holds true for every element, otherwise #f"
	(cond ((nil? l) #t)
	      ((not (pred (car l))) #f)
	      (#t (for-all? (cdr l) pred)))))

(def odd? (λ (a) "Predicate that returns #t if a is odd"
	(= (% (int a) 2) 1)))

(def even? (λ (a) "Predicate that returns #t if a is even"
	(= (% (int a) 2) 0)))

(def procedure? (λ (a) "Returns #t if a is a native or lisp function"
	(or (lambda? a) (native? a))))
; Put all the LISt Processing stuff in here

(def except-last-pair (λ (l r) "Returns a copy of li without the last pair"
	(if (nil? (cdr l)) (reverse r) (except-last-pair (cdr l) (cons (car l) r)))))

(def make-list (λ (i e l) "Returns a list of i elements containing e in every car"
	(if (<= i 0) l (make-list (-- i) e (cons e l)))))

(def reduce (λ (o l s) "Combines all elements in l using operation o and starting value s"
	(if (nil? l) s (reduce o (cdr l) (o s (car l))))))

(def list-ref (λ (l i) "Returns the the element of list l at location i"
	(cond ((nil? l) #nil)
	      ((<= i 0) (car l))
              (#t (list-ref (cdr l) (-- i))))))

(def join-iter (λ (s l glue) "Iter for join"
	(cond ((nil? l) (substr s 0 (- (str-len s) (str-len glue))))
	      (#t (join-iter (cat s (car l) glue) (cdr l) glue)))))
(def join (λ (l glue) "Joins all elements of L together with GLUE in between"
	(join-iter "" l (str glue))))

(def split (λ (s separator &start) "Splits String S on every SEPARATOR with &START=0"
	(let ((pos (index-of s separator (int &start))) (start (int &start)) (slen (str-len s)))
		(cond ((and (>= pos start) (< pos slen)) (cons (substr s start (max (+ start 1) pos)) (split s separator (+ pos (max 1 (str-len separator))))))
		      (#t (cons (substr s start slen)))))))

(def reverse (λ (l r) "Returns the list l in reverse order"
	(if (nil? l) r (reverse (cdr l) (cons (car l) r)))))

(def list-length (λ (a t) "Returns the length of list a"
	(if (nil? a) t (list-length (cdr a) (++ t)))))

(def filter (λ (p l) "Runs predicate p over every item in list l and returns a list consiting solely of items where p is true"
        (cond ((nil? l) #nil)
              ((p (car l)) (cons (car l) (filter p (cdr l))))
              (#t                       (filter p (cdr l))))))

(def map (λ (f l) "Runs f over every item in list l and returns the resulting list"
	(if (nil? l) l (cons (f (car l)) (map f (cdr l))))))

(def append-iter (λ (a b) "Iterator for append"
	(if (nil? a) b (append-iter (cdr a) (cons (car a) b)))))
(def append (λ (a b) "Appends to two lists a and b together"
	(append-iter (reverse a) b)))

(def sublist (λ (l start end ret) "Returns a new list containing all elements of l from start to end"
	(cond ((nil?    l) (reverse ret))
              ((neg?  end) (sublist      l      start  (+ (length l) end)))
              ((zero? end) (reverse ret))
              ((> start 0) (sublist (cdr l) (-- start) (-- end) #nil))
              ((> end   0) (sublist (cdr l) 0          (-- end) (cons (car l) ret))))))

(def list-head (λ (l k) "Returns the first k elemnts of list l"
	(sublist l 0 k)))

(def list-tail (λ (l k) "Returns the sublist of l obtained by omitting the first l elements"
	(sublist l k (length l))))

(def member (λ (m l) "Returns the first pair of list l whose car is equal to m"
	(cond ((nil? l) #f)
              ((eq? (car l) m) l)
              (#t (member m (cdr l))))))

(def delete (λ (e l) "Returns a filtered list l with all elements equal to e omitted"
	(filter (λ (a) (not (eq? a e))) l)))

(def arg-list (λ (f) "Returns the Argument list of f which can be a Native Function or a Lambda"
	(cond ((lambda? f) (reduce cat (map (λ (a) (" " (car a))) (cl-data f))))
	      ((native? f) (reduce cat (map (λ (a) (" " a)) (car (cl-data f)))))
	      (#t ""))))
