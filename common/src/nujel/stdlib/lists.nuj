; Put all the LISt Processing stuff in here

(def except-last-pair (λ (l r) "Returns a copy of li without the last pair"
	(if (nil? (cdr l)) (reverse r) (except-last-pair (cdr l) (cons (car l) r)))))

(def make-list (λ (i e l) "Returns a list of i elements containing e in every car"
	(if (<= i 0) l (make-list (-- i) e (cons e l)))))

(def reduce (λ (o l s) "Combines all elements in l using operation o and starting value s"
	(if (nil? l) s (reduce o (cdr l) (o s (car l))))))

(def list-ref (λ (l i) "Returns the the element of list l at location i"
	(cond ((nil? l) #nil)
	      ((<= i 0) (car l))
              (#t (list-ref (cdr l) (-- i))))))

(def join-iter (λ (s l glue) "Iter for join"
	(cond ((nil? l) (substr s 0 (- (str-len s) (str-len glue))))
	      (#t (join-iter (cat s (car l) glue) (cdr l) glue)))))
(def join (λ (l glue) "Joins all elements of L together with GLUE in between"
	(join-iter "" l (str glue))))

(def split (λ (s separator &start) "Splits String S on every SEPARATOR with &START=0"
	(let ((pos (max (+ (int &start) 1) (index-of s separator (int &start)))) (start (int &start)) (slen (str-len s)))
		(cond ((and (>= pos start) (< pos slen)) (cons (substr s start pos) (split s separator (+ pos (str-len separator)))))
		      (#t (cons (substr s start slen)))))))

(def reverse (λ (l r) "Returns the list l in reverse order"
	(if (nil? l) r (reverse (cdr l) (cons (car l) r)))))

(def list-length (λ (a t) "Returns the length of list a"
	(if (nil? a) t (list-length (cdr a) (++ t)))))

(def filter (λ (p l) "Runs predicate p over every item in list l and returns a list consiting solely of items where p is true"
        (cond ((nil? l) #nil)
              ((p (car l)) (cons (car l) (filter p (cdr l))))
              (#t                       (filter p (cdr l))))))

(def map (λ (f l) "Runs f over every item in list l and returns the resulting list"
	(if (nil? l) l (cons (f (car l)) (map f (cdr l))))))

(def append-iter (λ (a b) "Iterator for append"
	(if (nil? a) b (append-iter (cdr a) (cons (car a) b)))))
(def append (λ (a b) "Appends to two lists a and b together"
	(append-iter (reverse a) b)))

(def sublist (λ (l start end ret) "Returns a new list containing all elements of l from start to end"
	(cond ((nil?    l) (reverse ret))
              ((neg?  end) (sublist      l      start  (+ (length l) end)))
              ((zero? end) (reverse ret))
              ((> start 0) (sublist (cdr l) (-- start) (-- end) #nil))
              ((> end   0) (sublist (cdr l) 0          (-- end) (cons (car l) ret))))))

(def list-head (λ (l k) "Returns the first k elemnts of list l"
	(sublist l 0 k)))

(def list-tail (λ (l k) "Returns the sublist of l obtained by omitting the first l elements"
	(sublist l k (length l))))

(def member (λ (m l) "Returns the first pair of list l whose car is equal to m"
	(cond ((nil? l) #f)
              ((eq? (car l) m) l)
              (#t (member m (cdr l))))))

(def delete (λ (e l) "Returns a filtered list l with all elements equal to e omitted"
	(filter (λ (a) (not (eq? a e))) l)))

(def arg-list (λ (f) "Returns the Argument list of f which can be a Native Function or a Lambda"
	(cond ((lambda? f) (reduce cat (map (λ (a) (" " (car a))) (cl-data f))))
	      ((native? f) (reduce cat (map (λ (a) (" " a)) (car (cl-data f)))))
	      (#t ""))))
