;; Wolkenwelten - Copyright (C) 2020-2021 - Benjamin Vincent Schulenburg
;;
;; This program is free software: you can redistribute it and/or modify
;; it under the terms of the GNU Affero General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or
;; (at your option) any later version.
;;
;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU Affero General Public License for more details.
;;
;; You should have received a copy of the GNU Affero General Public License
;; along with this program.  If not, see <http://www.gnu.org/licenses/>.

;; Contains various little pieces that were implemented in nujel instead of
;; C because of various reasons

(def cddr (λ (p) "Short for (cdr (cdr p))"
	(cdr (cdr p))))

(def cadr (λ (p) "Short for (car (cdr p))"
	(car (cdr p))))

(def caddr (λ (p) "Short for (car (cdr (cdr p)))"
	(car (cdr (cdr p)))))

(def except-last-pair (λ (l r) "Returns a copy of li without the last pair"
	(if (nil? (cdr l)) (reverse r) (except-last-pair (cdr l) (cons (car l) r)))))

(def make-list (λ (i e l) "Returns a list of i elements containing e in every car"
	(if (<= i 0) l (make-list (-- i) e (cons e l)))))

(def reduce (λ (o l s) "Combines all elements in l using operation o and starting value s"
	(if (nil? l) s (reduce o (cdr l) (o s (car l))))))

(def list-ref (λ (l i) "Returns the the element of list l at location i"
	(cond ((nil? l) #nil)
	      ((<= i 0) (car l))
              (#t (list-ref (cdr l) (-- i))))))

(def ++ (λ (i) "Returns its argument + 1"
	(+ i 1)))

(def -- (λ (i) "Returns its argument - 1"
	(- i 1)))

(def reverse (λ (l r) "Returns the list l in reverse order"
	(if (nil? l) r (reverse (cdr l) (cons (car l) r)))))

(def list-length (λ (a t) "Returns the length of list a"
	(if (nil? a) t (list-length (cdr a) (++ t)))))

(def length (λ (a) "Returns the length of a"
	(cond ((string? a) (str-len a))
              ((pair? a) (list-length a))
              (#t 0))))

(def filter (λ (p l) "Runs predicate p over every item in list l and returns a list consiting solely of items where p is true"
        (cond ((nil? l) #nil)
              ((p (car l)) (cons (car l) (filter p (cdr l))))
              (#t                       (filter p (cdr l))))))

(def map (λ (f l) "Runs f over every item in list l and returns the resulting list"
	(if (nil? l) l (cons (f (car l)) (map f (cdr l))))))

(def append-iter (λ (a b) "Iterator for append"
	(if (nil? a) b (append-iter (cdr a) (cons (car a) b)))))
(def append (λ (a b) "Appends to two lists a and b together"
	(append-iter (reverse a) b)))

(def sublist (λ (l start end ret) "Returns a new list containing all elements of l from start to end"
	(cond ((nil?    l) (reverse ret))
              ((neg?  end) (sublist      l      start  (+ (length l) end)))
              ((zero? end) (reverse ret))
              ((> start 0) (sublist (cdr l) (-- start) (-- end) #nil))
              ((> end   0) (sublist (cdr l) 0          (-- end) (cons (car l) ret))))))

(def list-head (λ (l k) "Returns the first k elemnts of list l"
	(sublist l 0 k)))

(def list-tail (λ (l k) "Returns the sublist of l obtained by omitting the first l elements"
	(sublist l k (length l))))

(def member (λ (m l) "Returns the first pair of list l whose car is equal to m"
	(cond ((nil? l) #f)
              ((eq? (car l) m) l)
              (#t (member m (cdr l))))))


(def delete (λ (e l) "Returns a filtered list l with all elements equal to e omitted"
	(filter (λ (a) (not (eq? a e))) l)))

(def arg-list (λ (f) "Returns the Argument list of f which can be a Native Function or a Lambda"
	(cond ((lambda? f) (reduce cat (map (λ (a) (" " (car a))) (cl-data f))))
	      ((native? f) (reduce cat (map (λ (a) (" " a)) (car (cl-data f)))))
	      (#t ""))))

(def describe (λ (a) "Returns the DocString to its argument, if available"
	(cond ((not (string? a)) "Please quote the symbol in question, like (describe \"help\")")
	      (#t (let ((ds (car (cl-text (resolve (str->sym a)))))
	      (args (arg-list (resolve (str->sym a))))
	      (fn (cat a)))
		("(" fn args ") - " (if (string? ds) ds "No DocString found")))))))

(def display (λ (a) "Displays its argument"
	(print a)))

(def newline (λ () "Prints a single line feed character"
	(display "\n")))

(def list (λ (...l) "Returns its arguments as a list"
	...l))

(def when   (δ (c @...expr) "Evaluates l and returns the last result if c is #t"
	(cond (c (eval (cons 'begin @...expr))) (#t #f))))
(def unless (δ (c @...expr) "Evaluates l and returns the last result if c is #f"
	(cond (c #f) (#t (eval (cons 'begin @...expr))))))

(def arr-fill! (λ (a v i) "Fills array a with value v"
	(cond ((>= i (arr-length a)) a)
	      (#t (a (int i) v) (arr-fill! a v (++ i))))))

(def min-iter (λ (a l) "Iter for (min)"
	(cond ((nil? l) a)
	      ((< a (car l)) (min-iter a (cdr l)))
	      (#t (min-iter (car l) (cdr l))))))
(def min (λ (...l) "Returns the minimum value of its arguments"
	(cond ((nil? ...l) 0)
	      ((nil? (cdr ...l)) (car ...l))
	      (#t (min-iter (car ...l) (cdr ...l))))))

(def max-iter (λ (a l) "Iter for (max)"
	(cond ((nil? l) a)
	      ((> a (car l)) (max-iter a (cdr l)))
	      (#t (max-iter (car l) (cdr l))))))
(def max (λ (...l) "Returns the maximum value of its arguments"
	(cond ((nil? ...l) 0)
	      ((nil? (cdr ...l)) (car ...l))
	      (#t (max-iter (car ...l) (cdr ...l))))))
