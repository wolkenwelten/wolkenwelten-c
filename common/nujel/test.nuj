(def error-count 0)
(def success-count 0)

(def test (lambda (result @...expr) "Tests that @...EXPR evaluates to RESULT"
	(let ((expr (eval (cons begin @...expr))))
		(cond ((eq? result expr) (set! success-count (++ success-count)) (display (cat (ansi-green "[YEAH]") " " result "\t" (substr (write-str @...expr) 0 40) "\n")))
			(#t (set! error-count (++ error-count)) (display (cat (ansi-red "[NOES]") " " result " != " expr "\n" (write-str @...expr) "\n\n")))))))

(def test-str (lambda (result @...expr) "Tests that @...EXPR evaluates to RESULT"
	(let ((expr (write-str (eval (cons begin @...expr)))))
		(cond ((eq? result expr) (set! success-count (++ success-count)) (display (cat (ansi-green "[YEAH]") " " result "\t" (substr (write-str @...expr) 0 40) "\n")))
			(#t (set! error-count (++ error-count)) (display (cat (ansi-red "[NOES]") " " result " != " expr "\n" (write-str @...expr) "\n\n")))))))


(test 1073741824 (ash 1 30))
(test 2147483647 (lognot (ash 1 31)))
(test 39 (+ 42 (- 3)))
(test 24 (* 4 (- (+ 1 (+ 1 1)) (- 3 3 3))))
(test 3 (div 9 3))
(test 3 (let ((vier -4)) (+ (% 9 4) (/ -9 vier))))
(test 69 (+ (* 2 (/ 32 8) (- 16 8)) 5))
(test 3 (define eins 1) (define zwei 2) (+ eins zwei))
(test -3 (define eins 1) (define zwei 2) (define drei (+ eins zwei)) (set! eins (- drei drei drei)))
(test 128 (define zahl 1_2_8) zahl)
(test 10 (let ((a 10)) a))
(test 20 (define b 20) (let ((a b)) a))
(test 10 (define b 20) (let ((a b)) (set! a 10) a))
(test 20 (define b 20) (let ((a b)) (set! a 10) b))
(test 42 (let ((a 12) (b 30)) (+ a b)))
(test 16 (define square (lambda (a) (* a a))) (square 4))
(test 0 (- -1 -1))
(test #t (or #f (and (> 5 1) (not (< 5 1)) (>= 5 5) (<= 5 5))))
(test #t (and (= #t #t) (= #f #f) (not (= #f #t)) (= 2 "2")))
(test 11 (length "Hallo, Welt"))
(test #t (number? 0.1))
(test 14 (define abs (lambda (a) (if (neg? a) (- 0 a) a))) (+ (abs -7) (abs 7)))
(test #t (and (or #f #t) (and #t #t)))
(test #t (and (neg? -1) (neg? -0.01) (pos? 0) (pos? 0.01) (not (neg? 0)) (not (pos? -0.01)) (not (neg? #f))))
(test #t (and (number? 1) (number? -1) (number? 0) (number? 0.1)))
(test #t (and (number? (vec 1)) (not (number? #f)) (not (number? "123"))))
(test #t (and (number? 1) (number? -1) (number? 0) (number? 0.1) (number? (vec 1)) (not (number? #f)) (not (number? "123"))))
(test 12340 (- (int (cat 12 "3" "45 Test")) 5))
(test 12340 (let ((a (cat 12 "3" 45))) (- (int a) (length a))))
(test 123 (int (cat "123" "abc" 456)))
(test 28 (+ (int 10) (int 10.23) (int "8"))
(test #t (and (not (< 3 2)) (zero? 0) (> 3.1 2.1) (> 3 2) (>= 4 "3") (>= 3 3) (<= 3 3) (not (>= "2" 3)))
(test 1 (int (float (+ (vec 1) (vec 0 9 9)))))
(test 0 (- #nil))
(test #f (and #nil #nil))
(test #t (and (pair? (cons 1 '(2))) (not (pair? 1))))
(test 1 (car (cons 1 '(2))))
(test 2 (+ (cadr '(1 2)) (cadr #nil) (cadr '(1))))
(test #t (string? (describe "++")))
(test 3 (++ (-- (length '(1 2 3))))
(test #t (and (for-all? '(1 2 3) int?) (not (for-all? '(1 2 3.0) int?))))
(test #t (and (there-exists? '(1.0 2 3.0) int?) (not (there-exists? '(1.0 2.0 3.0) int?))))
(test #t (and (eq? "asd" "asd") (not (eq? "asd" "bsd")) (not (eq? "asd" "asdasd"))))
(test 23 (+ (reduce + (make-list 10 2)) (list-ref '(1 2 3 4) 1) (list-ref '(1 2) 3) (list-ref '(1 2) 0)))
(test #t (and (nil? #nil) (not (nil? "NotNil") (inf? #inf) (not (inf? "NotInf") (vec? (vec 1)) (not (inf? "NotVec"))))))
(test 11 (define count (let ((a 0)) (lambda (b) (set! a (+ a (cond ((number? b) b) (#t 1))))))) (count 10) (count))
(test 4 (let ((a 10)) (when (when #t (set! a (+ 2 "2")) #f) (set! a -1)) a))
(test 6 (eval '(+ 1 2 3)))
(test 4 (arr-length #(1 2 3 4)))
(test 2 (arr-ref #(1 2 3 4) 1))
(test 3 (arr-length (arr-new 3)))
(test 10 (+ (apply + '(1 2 3)) (apply ++ 3))
(test 0 (apply +))
(test 0 (define cb '+) (apply cb))
(test 1 (define cb '++) (apply cb))
(test 5 (length "12345"))
(test #f (or 0 0))
(test #t (and 1 1))
(test #f (bool 0))
(test #t (bool 1))
(test 6 ((lambda (a) (+ a 4)) 2))
(test 2 (define test 1) (define test 2) test)
(test 0 (max))
(test 0 (min))
(test 1 (max 1))
(test 4 (min 4))
(test 4 (min 4 9))
(test 9 (max 4 9))
(test 25 (max 1 4.0 9 25))
(test 1 (min 1 4.0 9 25))
(test #t (even? 2))
(test #f (even? 9))
(test #t (odd? 7))
(test #f (odd? 4))
(test 256 (int (pow 2 8)))
(test #f (undefine! testerle))
(test 3 (define test #(1 2 3)) (test 2))
(test 9 (define test #(1 2 3)) (test 2 9) (test 2))
(test 123 (define i-assaultmegablaster 123) i-assaultmegablaster)
(test #t (int? (random)))
(test #t (random-seed 123) (define first-value (random)) (random-seed 123) (= first-value (random)))
(test 1 (define a 1) (unless (= 2 2) (set! a 4)) a)
(test 4 (define a 1) (unless (= 2 3) (set! a 4)) a)
(test 4 (define a 1) (when   (= 2 2) (set! a 4)) a)
(test 1 (define a 1) (when   (= 2 3) (set! a 4)) a)
(test 3 (define test #(1 2 3)) (test 2.2))
(test 123 #d123)
(test 6 #b0110)
(test 10 #b1010)
(test 15 #b11-11)
(test 192 #b1100_0000)
(test 255 #xFF)
(test 255 #xFf)
(test 160 #xa0)
(test 31 #x1-F)
(test 31 #x1_F)
(test 50 #x32)
(test 256 #x100)
(test 0 #o)
(test 7 #o7)
(test 0 #o8)
(test 10 #o12)
(test 26 #o32)
(test -1 #b11111111_11111111_11111111_11111111)
(test -1 #xFFFFFFFF)
(test 2 (- (+ 1 #b10) 1))
(test 8 (- (+ 1 #o10) 1))
(test 16 (- (+ 1 #x10) 1))
(test 32 (+ #x10#x10))
(test 16 (+ #x10#f))
(test 32 (+ #x10"16"))
(test 32 (+ #x10(+ 0#x10)))
(test 0 (logand #xf0 #x0F))
(test 255 (logior #xf0 #x0F))
(test 255 (logior #xfF #xFF))
(test 255 (logxor #xf0 #x0F))
(test 240 (logxor #xff #x0F))
(test -1 (lognot 0))
(test 0 (lognot -1))
(test 16 (ash 1 4))
(test 65536 (ash 1 16))
(test -1 (ash -1 -1))
(test -16 (lognand #b1111 #b1111))
(test 6 (eval (read "(+ 1 2 3)")))
(test-str "(1 2 3)" (1 2 3))
(test-str "(vec 1.0 2.0 3.0)" (abs (vec -1 -2 -3)))
(test-str "3.33333" (+ 1.11111 2.22222))
(test-str "\"H#Hallo\"" (let ((a "Hallo, Welt#")) (cat (substr a 0 1) (substr a -1) (substr a 0 -7))))
(test-str "\"Test\"" (define a "Test") a)
(test-str "11.6" (+ (+ 1.1 2.2) (+ 1.1 3) (+ 1 3.2)))
(test-str "20.1" (+ (+ 1.1 3) (+ 1 3.3) (+ 3.3 4.1 4.3)))
(test-str "15.54" (add (mul 3.2 3.2) (sub 5.5 1.1 1 1.1) (div 9.9 3.3)))
(test-str "0.7" (% 10 3.1))
(test #t (eq? #inf #inf))
(test #inf (+ 1 (div 10 0)))
(test-str "11.7" (add (+ 1.1 2.2) (+ 1.1 3) (+ 1 3.3)))
(test-str "11.75" (+ (float 10) (int "10") (float "-8.25")))
(test-str "30.3" (+ (abs "-10") (int 8.2) 12.3))
(test-str "(vec 12.0 12.0 12.0)" (+ (vec 1) 1 10))
(test-str "(vec 3.0 5.0 6.0)" (+ (vec 1) (vec 1 2) (vec 1 2 3)))
(test-str "(vec 3.0 3.0 3.0)" (+ 1 (vec 1) 1.0))
(test-str "(vec 3.0 3.0 3.0)" (+ 1.0 (vec 1) "1"))
(test-str "(vec -1.0 -1.0 -1.0)" (- (vec 1) (vec 1.0) (vec "1")))
(test-str "2.7" (+ (- 1 -1.0) (- 5 1.1 1) (- 1 1.1 1) (- 1 1.1 (int "1"))))
(test-str "(vec 3.0 3.0 3.0)" (+ 1 (vec 1) 1.0))
(test-str "(vec -1.0 -1.0 -1.0)" (- 1 (vec 1) 1.0))
(test-str "(vec 8.0 8.0 8.0)" (* (vec 2) "4"))
(test-str "(vec 1.0 1.0 1.0)" (mod (vec 9) 2))
(test-str "1.0" (float (int (+ (vec 1) (vec 0 9 9)))))
(test-str "()" (cons))
(test-str "(1)" (cons 1))
(test-str "(1 . 2)" (cons 1 2))
(test-str "(1 2)" (cons 1 '(2)))
(test-str "(4 3 2 1)" (reverse '(1 2 3 4)))
(test-str "(1 2.0 3 1 2.0 3)" (append '(1 2.0 3) '(1 2.0 3)))
(test-str "(1 4)" (filter int?   '(1 2.0 #t 4)))
(test-str "(2.0)" (filter float? '(1 2.0 #t 4)))
(test-str "(2.0)" (filter float? '(1 2.0 #t 4)))
(test-str "(#t)"  (filter bool?  '(1 2.0 #t 4)))
(test-str "(2 3)" (sublist '(1 2 3 4 5 6) 1 3))
(test-str "(1 2 3)" (list-head '(1 2 3 4 5 6) 3))
(test-str "(4 5 6)" (list-tail (list 1 2 3 4 5 6) 3))
(test-str "(3)" (last-pair (list 1 2 3)))
(test-str "(1 2)" (except-last-pair '(1 2 3)))
(test-str "(1.0 #t \"a\")" (let ((l '(1.0 #t "a"))) (append (except-last-pair l) (last-pair l))))
(test-str "(\"asd\" #t #f)" (member "asd" '(123 456 "asd" #t #f)))
(test-str "((vec 4.0 4.0 4.0) 9 16.0)" (map (lambda (a) (* a a)) (cons (vec 2) '(3 4.0))))
(test-str "\"11.0\"" (cat 1 1.0))
(test-str "(vec 9.0 9.0 9.0)" (div (vec 99) (cat 1 1.0)))
(test-str "#(99 12 3 4)" (let ((cur-arr #(1 2 3 4))) (arr-set! cur-arr 0 99 12) cur-arr))
(test-str "#(42 42)" (arr-fill! (arr-new 2) 42))
(test-str "#nil" (apply #nil))
(test-str "(vec 1.0 3.0 9.0)" (define vs (lambda (a) (vec (vz a) (vy a) (vx a)))) (vs (vec 9 3.0 "1")))
(test-str "3" (define fib (lambda (a) (cond ((zero? a) 0) ((= a 1) 1) (#t (+ (fib (- a 1)) (fib (- a 2))))))) (fib 4))
(test-str "21" (define fib (lambda (a) (cond ((zero? a) 0) ((= a 1) 1) (#t (+ (fib (- a 1)) (fib (- a 2))))))) (fib 8))
(test-str "102334155" (define fib-iter (lambda (a b count) (cond ((= count 0) b) (#t (fib-iter (+ a b) a (- count 1)))))) (define fib (lambda (n) (fib-iter 1 0 n))) (fib 40))
(test-str "(Î» (a b c) (+ a b c))" (lambda (a b c) (+ a b c)))
(test 87654321 (let ((ret "")) ((lambda (a) (cond ((zero? a) (int ret)) (#t (set! ret (cat ret a)) ((cl-lambda 1) (-- a))))) 8)))
(test-str "3.14159" (set! PI 3) PI)
(test-str "\"ASD123\"" (str-up "asD123"))
(test-str "\"asd123\"" (str-down "aSD123"))
(test-str "\"Asd123\"" (str-capitalize "aSD123"))
(test-str "(vec 1.0 1.0 1.0)" (floor (vec 1.3 1.3 1.3)))
(test-str "2.0" (ceil 1.3))
(test-str "(vec 2.0 2.0 2.0)" (ceil (vec 1.3 1.3 1.3)))
(test-str "1.0" (round 1.3))
(test-str "2.0" (round 1.51))
(test-str "3.0" (sqrt 9))
(test-str "(vec 5.0 5.0 5.0)" (sqrt (vec 25 25 25)))
(test-str "256.0" (pow 2.0 8))
(test-str "(vec 4.0 8.0 16.0)" (pow 2.0 (vec 2.0 3.0 4.0)))
(test-str "\"123\"" (str 123))
(test-str "\"#t\"" (str #t))
(test-str "testerle" testerle)
(test-str "(:asd qwerty)" (:asd qwerty))
(test-str "testerle" (define testerle 123) (undefine! testerle) testerle)
(test-str "(1 . 2)" (define test (cons 1 2)) test)
(test-str "(3 . 2)" (define test (cons 1 2)) (set-car! test 3))
(test-str "(3 . 4)" (define test (cons 1 2)) (set-car! test 3) (set-cdr! test 4))
(test-str "\"Eins\"" (define eins (object () (define say (lambda () "Eins")))) (eins (say)))
(test-str "\"Eins\"" (define eins (object () (define say (lambda () "Eins")))) (define zwei (eins (object))) (zwei (say)))
(test-str "\"asd\"" ("a" "s" "d"))
(test-str "\"a\"" ("a"))
(test-str "#nil" (define testerle #(1 2 3)) (testerle 4))
(test-str "#nil" (define testerle #(1 2 3)) (testerle 40000))
(test-str "#(1 2 3)" (define testerle #(1 2 3)) (testerle))
(test-str "#nil" (define testerle #(1 2 3)) (testerle #t))
(test-str "#nil" (define testerle #(1 2 3)) (testerle (vec 1 2 3)))
(test-str "Trim Test" (trim "   Trim Test    \n"))

; Those have to wait until we can fork off another interpreter
; test_sexpr_exitcode "(quit (+ 20 3))" 23
; test_sexpr_oom "(define inf-loop (lambda (a) (inf-loop (++ a)))) (inf-loop)" ""
; test_sexpr "4 ; 5" "4"
; test_sexpr $'4 ; 5\n6' "6"

(display ("Results: " (ansi-green success-count) " / " (ansi-red error-count) "\n"))
(if (zero? error-count) (quit 0) (quit 1))
